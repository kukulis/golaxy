 type BattleHandler struct {
      decisionProducer DecisionProducer  // Injected via setter
      idGenerator      IdGenerator

      // Battle state (implements BattleState interface)
      postSideA *Fleet
      postSideB *Fleet
      poolA     *IndexPool
      poolB     *IndexPool
      shipMapA  map[string]*ShipRef
      shipMapB  map[string]*ShipRef
  }

  // Constructor - minimal initialization
  func NewBattleHandler(idGenerator IdGenerator) *BattleHandler {
      return &BattleHandler{
          idGenerator: idGenerator,
      }
  }

  // DI Setter
  func (bh *BattleHandler) SetDecisionProducer(producer DecisionProducer) {
      bh.decisionProducer = producer
  }

  func (bh *BattleHandler) ExecuteBattle(fleetA, fleetB *Fleet) *Battle {
      // Nil check with panic
      if bh.decisionProducer == nil {
          panic("BattleHandler: DecisionProducer not set. Call SetDecisionProducer() before ExecuteBattle()")
      }

      // ... create battle, copy fleets to PostSideA/PostSideB

      // Initialize battle state (pools, maps)
      bh.initializeBattleState()

      // Inject BattleState into producer (BattleHandler implements BattleState)
      bh.decisionProducer.SetBattleState(bh)

      // Execute battle
      shots := []*Shot{}
      for {
          shot := bh.decisionProducer.ProduceNextShot()
          if shot == nil {
              break
          }
          shotRecord := bh.applyShot(shot)
          shots = append(shots, shotRecord)
      }

      battle.Shots = shots
      return &battle
  }

  // BattleHandler implements BattleState interface
  func (bh *BattleHandler) GetAliveShipCount(side Side) int {
      return bh.getPool(side).Count()
  }
  // ... other BattleState methods

  DecisionProducer Interface

  type DecisionProducer interface {
      SetBattleState(state BattleState)  // DI setter
      ProduceNextShot() *ShotDecision     // No parameters
  }

  type BattleState interface {
      GetAliveShipCount(side Side) int
      GetAliveShipAt(side Side, position int) *Ship
      GetShipByID(side Side, shipID string) *Ship
      IsBattleOver() bool
  }

  RuntimeDecisionProducer

  type RuntimeDecisionProducer struct {
      battleState         BattleState  // Injected via setter
      rng                 RandomGenerator
      destructionFunction *ConfigurableFunction

      currentSide      *Side
      currentShooterID string
      remainingShots   int
  }

  // Constructor
  func NewRuntimeDecisionProducer(rng RandomGenerator) *RuntimeDecisionProducer {
      f, _ := NewConfigurableFunction(...)
      return &RuntimeDecisionProducer{
          rng:                 rng,
          destructionFunction: f,
      }
  }

  // DI Setter
  func (r *RuntimeDecisionProducer) SetBattleState(state BattleState) {
      r.battleState = state
      r.currentSide = nil  // Reset shooter state for new battle
  }

  func (r *RuntimeDecisionProducer) ProduceNextShot() *ShotDecision {
      // Nil check with panic
      if r.battleState == nil {
          panic("RuntimeDecisionProducer: BattleState not set. Call SetBattleState() before ProduceNextShot()")
      }

      if r.battleState.IsBattleOver() {
          return nil
      }

      if r.currentSide == nil {
          r.selectNewShooter()
      }

      // ... rest of implementation using r.battleState

      return &ShotDecision{...}
  }

  PredefinedDecisionProducer

  type PredefinedDecisionProducer struct {
      shots []ShotDecision
      index int
      // No battleState field - doesn't need it
  }

  func NewPredefinedDecisionProducer(shots []ShotDecision) *PredefinedDecisionProducer {
      return &PredefinedDecisionProducer{
          shots: shots,
          index: 0,
      }
  }

  // DI Setter (no-op implementation)
  func (p *PredefinedDecisionProducer) SetBattleState(state BattleState) {
      // No-op: PredefinedDecisionProducer doesn't use BattleState
  }

  func (p *PredefinedDecisionProducer) ProduceNextShot() *ShotDecision {
      // No nil check needed - doesn't use battleState
      if p.index >= len(p.shots) {
          return nil
      }
      shot := p.shots[p.index]
      p.index++
      return &shot
  }
